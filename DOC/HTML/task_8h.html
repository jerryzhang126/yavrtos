<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: task.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>task.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsemaphore__t.html">semaphore_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing a semaphore.  <a href="structsemaphore__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmailbox__t.html">mailbox_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing mailboxes.  <a href="structmailbox__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtask__t.html">task_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing a task.  <a href="structtask__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutex__t.html">mutex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure describing a mutex.  <a href="structmutex__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyavrtos__system__struct.html">yavrtos_system_struct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Structure used by the system to hold the system stack, and a flag indicating whether an ISR is currently being executed. </p>
 <a href="structyavrtos__system__struct.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#g25bd2a38df25c412fa196810cced903f">YAVRTOS_OK</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OK.  <a href="group__returnvalues.html#g25bd2a38df25c412fa196810cced903f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#g4beeb9aae0810fb5c55feaa5dc45d005">YAVRTOS_INVALID_TASK</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalid task state.  <a href="group__returnvalues.html#g4beeb9aae0810fb5c55feaa5dc45d005"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#gf809c5a1688049a2aa18fec282aef612">YAVRTOS_IDLE_TASK</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalid function for idle task.  <a href="group__returnvalues.html#gf809c5a1688049a2aa18fec282aef612"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#g6db4c87109a94aaf212756cc2abd8163">YAVRTOS_ISR</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalid function for an ISR.  <a href="group__returnvalues.html#g6db4c87109a94aaf212756cc2abd8163"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#g7f9ddf1377159b76dee774364c21d65b">YAVRTOS_TIMEOUT</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeout.  <a href="group__returnvalues.html#g7f9ddf1377159b76dee774364c21d65b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#g9d2c70d5dca1fab27674ee29381ec9dc">YAVRTOS_NOT_OWNER</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not the mutex owner.  <a href="group__returnvalues.html#g9d2c70d5dca1fab27674ee29381ec9dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#gad067b4a1aca28bcc57994fb34f7fb3f">YAVRTOS_RTOS_NOT_STARTED</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RTOS not started.  <a href="group__returnvalues.html#gad067b4a1aca28bcc57994fb34f7fb3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#ge3b63fc25ea0bb78bf65700a6b9d22ad">YAVRTOS_MBOX_NOT_EMPTY</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mailbox not empty.  <a href="group__returnvalues.html#ge3b63fc25ea0bb78bf65700a6b9d22ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#geb226d4270f81fbc1747f580defd214f">YAVRTOS_ALREADY_STOPPED</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The task was already stopped.  <a href="group__returnvalues.html#geb226d4270f81fbc1747f580defd214f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g42c4528688cb31827aa5efb696995642">interrupt_store_t</a>&nbsp;&nbsp;&nbsp;uint8_t</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A flag indicating whether interrupts were enabled - used by <a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f" title="Disable interrupts system-wide.">disable_interrupts()</a> and <a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf" title="Restore the state of the system-wide interrupts.">restore_interrupts()</a>.  <a href="group__task.html#g42c4528688cb31827aa5efb696995642"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#bedcaab91615f58a55ed4135438618e8">save_cpu_context</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Save the CPU context to the stack, and disable interrupts </p>
 <a href="#bedcaab91615f58a55ed4135438618e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#7e11bac5a51572c5db72502c47cf90d3">restore_cpu_context</a>()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Restore the CPU context from the stack, possibly re-enabling interrupts </p>
 <a href="#7e11bac5a51572c5db72502c47cf90d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0">TASK_ISR</a>(vector, do_task_switch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The macro for ISRs.  <a href="group__isr.html#g3d04938242a5060aac8a64b72c055eb0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function return value.  <a href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135">reserve_task</a> (uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tasks are kept in a linked list in memory - this function reserves an "empty" task on that list, ready to be subsequently utilised by a call to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>.  <a href="group__task.html#g934155282a1d689b554e90b5138e5135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3">create_task</a> (void(*proc)(void *), void(*cleanup)(), void *init_data, uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task, ready to be run.  <a href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gb643e14677f59566123cdf76c5e476ee">stop_task</a> (<a class="el" href="structtask__t.html">task_t</a> *t, uint8_t wait_for_mutexes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop a task.  <a href="group__task.html#gb643e14677f59566123cdf76c5e476ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db">yield</a> () __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop executing the current task and try and execute a higher-priority task or another task of the same priority.  <a href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g9764d628239e4ab2f1b8293ae4af0bcb">lock_on</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock on a mutex.  <a href="group__mutex.html#g9764d628239e4ab2f1b8293ae4af0bcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g6221f19e85acc1c15bd8aea076fdd191">lock_off</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="group__mutex.html#g6221f19e85acc1c15bd8aea076fdd191"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef">get_current_mbox_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current version of a mailbox.  <a href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g22cb125a008b812c74c16230b39bde02">read_mbox_min_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, int16_t *version, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a mailbox to reach at least a certain version, and then start reading from it.  <a href="group__mailbox.html#g22cb125a008b812c74c16230b39bde02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6">read_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, int16_t *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a mailbox.  <a href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmailbox__t.html">mailbox_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96">release_mbox_read</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to call when finished reading from a mailbox.  <a href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd">initialise_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, void *data, const int16_t version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a mailbox - this <b>must</b> be called on every mailbox before it is used.  <a href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g16eb42fc91f2c7bd318746288b2b376c">write_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, void *data, uint8_t wait_for_receivers, uint8_t wait_for_empty_nullify, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a mailbox.  <a href="group__mailbox.html#g16eb42fc91f2c7bd318746288b2b376c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g8518f240fd3a62050dd3a865312870b5">write_mbox_now</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to write to a mailbox.  <a href="group__mailbox.html#g8518f240fd3a62050dd3a865312870b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g1649c1ac81545f82e9b51350f86c9757">wait_for_receiver</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *mbox, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a task to be suspended while trying to read from a mailbox.  <a href="group__mailbox.html#g1649c1ac81545f82e9b51350f86c9757"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g67ef58e79db653cb0d89b7e34d202c20">wait_for_min_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s, int16_t value, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to reach at least a particular value.  <a href="group__semaphore.html#g67ef58e79db653cb0d89b7e34d202c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gdcd144da882276f3056b1d5bc6c55872">wait_for_min_value_timeout</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, int16_t value, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to reach at least a particular value, but with a set value for the timeout, as opposed to an increment to the timeout semaphore value.  <a href="group__semaphore.html#gdcd144da882276f3056b1d5bc6c55872"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g231a5998148f9c977599f9cd5950f8c7">wait_for_increment_of</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, uint16_t amount, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to increment its value by a certain amount.  <a href="group__semaphore.html#g231a5998148f9c977599f9cd5950f8c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gfe03c1bf996269f138eef7fc69393f24">wait_for_increment_of_timeout</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, uint16_t amount, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to increment its value by a certain amount, but with a set value for the timeout, as opposed to an increment to the timeout semaphore value.  <a href="group__semaphore.html#gfe03c1bf996269f138eef7fc69393f24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2">get_semaphore_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current value of a semaphore.  <a href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008">increment_semaphore_by</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s, uint16_t amount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the value of a semaphore by the given amount.  <a href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521">task_switcher_start</a> (void(*idle)(void *), void *idle_data, uint16_t idle_stacklen, uint16_t system_stacklen) __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the whole process running.  <a href="group__task.html#g1398c4d9f97349ea3fa7d91349298521"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">interrupt_store_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f">disable_interrupts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable interrupts system-wide.  <a href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf">restore_interrupts</a> (interrupt_store_t interrupts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore the state of the system-wide interrupts.  <a href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#6587681a992e6e80317747df4d29b46b">switch_task</a> () __attribute__((naked))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Perform a task switch. </p>
 <a href="#6587681a992e6e80317747df4d29b46b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current task.  <a href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structyavrtos__system__struct.html">yavrtos_system_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8h.html#f7948aead206052d6c5052462a485a97">yavrtos_system</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The system_struct used to hold the system stack and a flag indicating whether an ISR is currently being executed </p>
 <a href="#f7948aead206052d6c5052462a485a97"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="7e11bac5a51572c5db72502c47cf90d3"></a><!-- doxytag: member="task.h::restore_cpu_context" ref="7e11bac5a51572c5db72502c47cf90d3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define restore_cpu_context          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">__asm__ <span class="keyword">volatile</span> ( \
                <span class="stringliteral">"pop r0\n"</span> \
                <span class="stringliteral">"pop r31\n pop r30\n pop r29\n pop r28\n pop r27\n pop r26\n pop r25\n pop r24\n"</span> \
                <span class="stringliteral">"pop r23\n pop r22\n pop r21\n pop r20\n pop r19\n pop r18\n pop r17\n pop r16\n"</span> \
                <span class="stringliteral">"pop r15\n pop r14\n pop r13\n pop r12\n pop r11\n pop r10\n pop  r9\n pop  r8\n"</span> \
                <span class="stringliteral">"pop  r7\n pop  r6\n pop  r5\n pop  r4\n pop  r3\n pop  r2\n pop  r1\n out 0x3f, r0\n pop  r0\n"</span> ::)
</pre></div><p><b>For internal use only.</b></p>
<p>
Restore the CPU context from the stack, possibly re-enabling interrupts </p>

<p>

</div>
</div><p>
<a class="anchor" name="bedcaab91615f58a55ed4135438618e8"></a><!-- doxytag: member="task.h::save_cpu_context" ref="bedcaab91615f58a55ed4135438618e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define save_cpu_context          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">__asm__ <span class="keyword">volatile</span>( \
                <span class="stringliteral">"push  r0\n in r0, 0x3f\n cli\n"</span> \
                <span class="stringliteral">"push  r1\n push  r2\n push  r3\n push  r4\n push  r5\n push  r6\n push  r7\n"</span> \
                <span class="stringliteral">"push  r8\n push  r9\n push r10\n push r11\n push r12\n push r13\n push r14\n push r15\n"</span> \
                <span class="stringliteral">"push r16\n push r17\n push r18\n push r19\n push r20\n push r21\n push r22\n push r23\n"</span> \
                <span class="stringliteral">"push r24\n push r25\n push r26\n push r27\n push r28\n push r29\n push r30\n push r31\n"</span> \
                <span class="stringliteral">"push  r0\n"</span> ::)
</pre></div><p><b>For internal use only.</b></p>
<p>
Save the CPU context to the stack, and disable interrupts </p>

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="6587681a992e6e80317747df4d29b46b"></a><!-- doxytag: member="task.h::switch_task" ref="6587681a992e6e80317747df4d29b46b" args="() __attribute__((naked))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_task           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Perform a task switch. </p>

<p>
Note that interrupts must be disabled before we enter. Note also that this function <b>must be programmed so that it never uses the stack</b>! 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="f7948aead206052d6c5052462a485a97"></a><!-- doxytag: member="task.h::yavrtos_system" ref="f7948aead206052d6c5052462a485a97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structyavrtos__system__struct.html">yavrtos_system_struct</a> <a class="el" href="task_8h.html#f7948aead206052d6c5052462a485a97">yavrtos_system</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The system_struct used to hold the system stack and a flag indicating whether an ISR is currently being executed </p>

<p>

</div>
</div><p>
<hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2009 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
