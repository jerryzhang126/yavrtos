<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>YAVRTOS: task.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>task.c File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#7a659118f2c006c2570742f06614eace">semaphore_triggered</a>(current, required)&nbsp;&nbsp;&nbsp;((current) - (required) &gt;= 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a semaphore been triggered?  <a href="#7a659118f2c006c2570742f06614eace"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g9fe746e46bba8481ba2b8d4a50074d16">YAVRTOS_TASK_STATE_STARTING</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting.  <a href="group__taskstategroup.html#g9fe746e46bba8481ba2b8d4a50074d16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g85f1df036416e0599a1f30917955f592">YAVRTOS_TASK_STATE_RUNNING</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Running.  <a href="group__taskstategroup.html#g85f1df036416e0599a1f30917955f592"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g399c0fe60a5700c6c96aa89d636ddc7d">YAVRTOS_TASK_STATE_WAITING_TO_STOP</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waiting for the task to release all of its mutexes before stopping.  <a href="group__taskstategroup.html#g399c0fe60a5700c6c96aa89d636ddc7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g72b1b306ddd47658837206f49402e974">YAVRTOS_TASK_STATE_STOPPING</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stopping.  <a href="group__taskstategroup.html#g72b1b306ddd47658837206f49402e974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g28e12c3c5ba0bcba12a42651769ee778">YAVRTOS_TASK_STATE_CLEANING_UP</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleaning up.  <a href="group__taskstategroup.html#g28e12c3c5ba0bcba12a42651769ee778"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__taskstategroup.html#g9df3cacab908c653aa6a5549a59a3353">YAVRTOS_TASK_STATE_STOPPED</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stopped.  <a href="group__taskstategroup.html#g9df3cacab908c653aa6a5549a59a3353"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#ec2cb6acfd1cbdf565d79d8e46366142">set_task_state</a>(taskptr, req_state)&nbsp;&nbsp;&nbsp;(taskptr)-&gt;status = (req_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Set the state of a task - this macro makes it easier to put other information into task.status </p>
 <a href="#ec2cb6acfd1cbdf565d79d8e46366142"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#73254a06adc660dd59b1770c9b9f3520">get_task_state</a>(taskptr)&nbsp;&nbsp;&nbsp;((taskptr)-&gt;status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Get the state of a task - this macro makes it easier to put other information into task.status </p>
 <a href="#73254a06adc660dd59b1770c9b9f3520"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#95d8d92f8a304e063ce50c912412181c">executing_isr</a>()&nbsp;&nbsp;&nbsp;(yavrtos_system.interrupted_task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Are we currently executing an ISR? </p>
 <a href="#95d8d92f8a304e063ce50c912412181c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#87b5d6c508a0039ac89b09c3c71f6717">rtos_started</a>()&nbsp;&nbsp;&nbsp;(<a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Has the RTOS been started? </p>
 <a href="#87b5d6c508a0039ac89b09c3c71f6717"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#c85c4cc0394680fc16ce32fcc987e62e">task_starter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The entry point for all tasks </p>
 <a href="#c85c4cc0394680fc16ce32fcc987e62e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#b1c4cc247bd379e340e25bd86911919d">task_stopper</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The entry point for all tasks that are stopping </p>
 <a href="#b1c4cc247bd379e340e25bd86911919d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gb643e14677f59566123cdf76c5e476ee">stop_task</a> (<a class="el" href="structtask__t.html">task_t</a> *t, uint8_t wait_for_mutexes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop a task.  <a href="group__task.html#gb643e14677f59566123cdf76c5e476ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g934155282a1d689b554e90b5138e5135">reserve_task</a> (uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tasks are kept in a linked list in memory - this function reserves an "empty" task on that list, ready to be subsequently utilised by a call to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>.  <a href="group__task.html#g934155282a1d689b554e90b5138e5135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3">create_task</a> (void(*proc)(void *), void(*cleanup)(), void *init_data, uint16_t stacklen, uint8_t pri, <a class="el" href="structmutex__t.html">mutex_t</a> *memory_mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task, ready to be run.  <a href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2">get_semaphore_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current value of a semaphore.  <a href="group__semaphore.html#g3c18e0f867a2f36f1510aebf5ad4c0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#a54619392fbe880e3bbdfdb52578cb65">perform_wait_on_semaphore</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, int8_t is_increment, int16_t value, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int8_t timeout_is_increment, int16_t timeout_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Perform a wait on a semaphore (all "perform wait on semaphore" functions call this one - it keeps the stack usage down). </p>
 <a href="#a54619392fbe880e3bbdfdb52578cb65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g67ef58e79db653cb0d89b7e34d202c20">wait_for_min_value</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, int16_t value, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to reach at least a particular value.  <a href="group__semaphore.html#g67ef58e79db653cb0d89b7e34d202c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gdcd144da882276f3056b1d5bc6c55872">wait_for_min_value_timeout</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, int16_t value, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to reach at least a particular value, but with a set value for the timeout, as opposed to an increment to the timeout semaphore value.  <a href="group__semaphore.html#gdcd144da882276f3056b1d5bc6c55872"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g231a5998148f9c977599f9cd5950f8c7">wait_for_increment_of</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, uint16_t amount, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to increment its value by a certain amount.  <a href="group__semaphore.html#g231a5998148f9c977599f9cd5950f8c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#gfe03c1bf996269f138eef7fc69393f24">wait_for_increment_of_timeout</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *p, uint16_t amount, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a semaphore to increment its value by a certain amount, but with a set value for the timeout, as opposed to an increment to the timeout semaphore value.  <a href="group__semaphore.html#gfe03c1bf996269f138eef7fc69393f24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g9764d628239e4ab2f1b8293ae4af0bcb">lock_on</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock on a mutex.  <a href="group__mutex.html#g9764d628239e4ab2f1b8293ae4af0bcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#g6221f19e85acc1c15bd8aea076fdd191">lock_off</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a mutex.  <a href="group__mutex.html#g6221f19e85acc1c15bd8aea076fdd191"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#aa4ee75536398ba2bd21466b13bdcd57">switch_task</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
Perform a task switch. </p>
 <a href="#aa4ee75536398ba2bd21466b13bdcd57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008">increment_semaphore_by</a> (<a class="el" href="structsemaphore__t.html">semaphore_t</a> *s, uint16_t amount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the value of a semaphore by the given amount.  <a href="group__semaphore.html#g3cd218588dccb32b5b9072c7a75fb008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef">get_current_mbox_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current version of a mailbox.  <a href="group__mailbox.html#g9b7e62ecd1a61eda8cfa1229df0728ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6">read_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, int16_t *version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a mailbox.  <a href="group__mailbox.html#g86030bb5345670ca374ddd20ef8e4ff6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g22cb125a008b812c74c16230b39bde02">read_mbox_min_version</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, int16_t *version, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a mailbox to reach at least a certain version, and then start reading from it.  <a href="group__mailbox.html#g22cb125a008b812c74c16230b39bde02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmailbox__t.html">mailbox_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96">release_mbox_read</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to call when finished reading from a mailbox.  <a href="group__mailbox.html#g31b8ee5f4cd547c128143d99ea1c4a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd">initialise_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, void *data, const int16_t version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a mailbox - this <b>must</b> be called on every mailbox before it is used.  <a href="group__mailbox.html#gd4cde27abfbedc7c8e854e76d71612dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#9963b4ea6e571f04447db7fa4a826d81">mbox_is_empty</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out if a mailbox is "empty" (i.e. if there is no-one waiting to read it).  <a href="#9963b4ea6e571f04447db7fa4a826d81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g16eb42fc91f2c7bd318746288b2b376c">write_mbox</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, void *data, uint8_t wait_for_receivers, uint8_t wait_for_empty_nullify, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to a mailbox.  <a href="group__mailbox.html#g16eb42fc91f2c7bd318746288b2b376c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g8518f240fd3a62050dd3a865312870b5">write_mbox_now</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to write to a mailbox.  <a href="group__mailbox.html#g8518f240fd3a62050dd3a865312870b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mailbox.html#g1649c1ac81545f82e9b51350f86c9757">wait_for_receiver</a> (<a class="el" href="structmailbox__t.html">mailbox_t</a> *m, <a class="el" href="structsemaphore__t.html">semaphore_t</a> *timeout_semaphore, int16_t timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a task to be suspended while trying to read from a mailbox.  <a href="group__mailbox.html#g1649c1ac81545f82e9b51350f86c9757"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">interrupt_store_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f">disable_interrupts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable interrupts system-wide.  <a href="group__task.html#g6984a5336b36a4ca99682a2cf5ae044f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf">restore_interrupts</a> (interrupt_store_t interrupts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore the state of the system-wide interrupts.  <a href="group__task.html#gecf8a8e43c2afae89e46503ff1c887bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db">yield</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop executing the current task and try and execute a higher-priority task or another task of the same priority.  <a href="group__task.html#g1a2a5bbefa85516b8c1d0e0361a834db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g1398c4d9f97349ea3fa7d91349298521">task_switcher_start</a> (void(*idle)(void *), void *idle_data, uint16_t idle_stacklen, uint16_t system_stacklen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the whole process running.  <a href="group__task.html#g1398c4d9f97349ea3fa7d91349298521"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtask__t.html">task_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current task.  <a href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structyavrtos__system__struct.html">yavrtos_system_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="task_8c.html#f7948aead206052d6c5052462a485a97">yavrtos_system</a> = {0}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><b>For internal use only.</b></p>
<p>
The system stack, and a flag indicating whether the CPU is currently processing an interrupt </p>
 <a href="#f7948aead206052d6c5052462a485a97"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="95d8d92f8a304e063ce50c912412181c"></a><!-- doxytag: member="task.c::executing_isr" ref="95d8d92f8a304e063ce50c912412181c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define executing_isr          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(yavrtos_system.interrupted_task)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Are we currently executing an ISR? </p>

<p>

</div>
</div><p>
<a class="anchor" name="73254a06adc660dd59b1770c9b9f3520"></a><!-- doxytag: member="task.c::get_task_state" ref="73254a06adc660dd59b1770c9b9f3520" args="(taskptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_task_state          </td>
          <td>(</td>
          <td class="paramtype">taskptr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((taskptr)-&gt;status)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Get the state of a task - this macro makes it easier to put other information into task.status </p>

<p>

</div>
</div><p>
<a class="anchor" name="87b5d6c508a0039ac89b09c3c71f6717"></a><!-- doxytag: member="task.c::rtos_started" ref="87b5d6c508a0039ac89b09c3c71f6717" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtos_started          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(<a class="el" href="group__task.html#g4743b3673a8794b8e7bd0b6c91a63cd5">current_task</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Has the RTOS been started? </p>

<p>

</div>
</div><p>
<a class="anchor" name="7a659118f2c006c2570742f06614eace"></a><!-- doxytag: member="task.c::semaphore_triggered" ref="7a659118f2c006c2570742f06614eace" args="(current, required)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define semaphore_triggered          </td>
          <td>(</td>
          <td class="paramtype">current,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">required&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((current) - (required) &gt;= 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has a semaphore been triggered? 
<p>
It is quite critical that this algorithm be correct, even when the semaphore values roll over 
</div>
</div><p>
<a class="anchor" name="ec2cb6acfd1cbdf565d79d8e46366142"></a><!-- doxytag: member="task.c::set_task_state" ref="ec2cb6acfd1cbdf565d79d8e46366142" args="(taskptr, req_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define set_task_state          </td>
          <td>(</td>
          <td class="paramtype">taskptr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">req_state&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(taskptr)-&gt;status = (req_state)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Set the state of a task - this macro makes it easier to put other information into task.status </p>

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="9963b4ea6e571f04447db7fa4a826d81"></a><!-- doxytag: member="task.c::mbox_is_empty" ref="9963b4ea6e571f04447db7fa4a826d81" args="(mailbox_t *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mbox_is_empty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmailbox__t.html">mailbox_t</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find out if a mailbox is "empty" (i.e. if there is no-one waiting to read it). 
<p>
<p><b>For internal use only.</b></p>
<p>
Note that interrupts must be disabled before we enter </p>

</div>
</div><p>
<a class="anchor" name="a54619392fbe880e3bbdfdb52578cb65"></a><!-- doxytag: member="task.c::perform_wait_on_semaphore" ref="a54619392fbe880e3bbdfdb52578cb65" args="(semaphore_t *p, int8_t is_increment, int16_t value, semaphore_t *timeout_semaphore, int8_t timeout_is_increment, int16_t timeout_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__returnvalues.html#g18b1933475c7acdac565040fbf64974e">yavrtos_result_t</a> perform_wait_on_semaphore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsemaphore__t.html">semaphore_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&nbsp;</td>
          <td class="paramname"> <em>is_increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsemaphore__t.html">semaphore_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timeout_semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&nbsp;</td>
          <td class="paramname"> <em>timeout_is_increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>timeout_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Perform a wait on a semaphore (all "perform wait on semaphore" functions call this one - it keeps the stack usage down). </p>

<p>
The arguments are <ul>
<li><code>p</code> - the semaphore to wait on </li>
<li><code>is_increment</code> - true if the value is an increment to the semaphore value as opposed to an absolute value </li>
<li><code>value</code> - either an increment to the semaphore value to wait for, or the absolute value to wait for </li>
<li><code>timeout_semaphore</code> - a semaphore to use for timing out while waiting on the other semaphore, or 0 if no timeout should be performed </li>
<li><code>timeout_is_increment</code> - true if the timeout_value is an increment to the timeout semaphore value as opposed to an absolute value </li>
<li><code>timeout_value</code> - either an increment to the timeout semaphore value to time out on, or the absolute value of the timeout semaphore value to time out on.</li>
</ul>
The possible return values are <ul>
<li><a class="el" href="group__returnvalues.html#g25bd2a38df25c412fa196810cced903f" title="OK.">YAVRTOS_OK</a> </li>
<li><a class="el" href="group__returnvalues.html#g6db4c87109a94aaf212756cc2abd8163" title="Invalid function for an ISR.">YAVRTOS_ISR</a> </li>
<li><a class="el" href="group__returnvalues.html#gf809c5a1688049a2aa18fec282aef612" title="Invalid function for idle task.">YAVRTOS_IDLE_TASK</a> </li>
<li><a class="el" href="group__returnvalues.html#g7f9ddf1377159b76dee774364c21d65b" title="Timeout.">YAVRTOS_TIMEOUT</a> </li>
</ul>

</div>
</div><p>
<a class="anchor" name="aa4ee75536398ba2bd21466b13bdcd57"></a><!-- doxytag: member="task.c::switch_task" ref="aa4ee75536398ba2bd21466b13bdcd57" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_task           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
Perform a task switch. </p>

<p>
Note that interrupts must be disabled before we enter. Note also that this function <b>must be programmed so that it never uses the stack</b>! 
</div>
</div><p>
<a class="anchor" name="c85c4cc0394680fc16ce32fcc987e62e"></a><!-- doxytag: member="task.c::task_starter" ref="c85c4cc0394680fc16ce32fcc987e62e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_starter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The entry point for all tasks </p>

<p>
First, interrupts are enabled, so that the tick interrupt can happen. Then, the task procedure is executed. When the task procedure exits, if the task priority is zero, it is re-executed. If the task priority isn't zero, the task is shut down. 
</div>
</div><p>
<a class="anchor" name="b1c4cc247bd379e340e25bd86911919d"></a><!-- doxytag: member="task.c::task_stopper" ref="b1c4cc247bd379e340e25bd86911919d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_stopper           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The entry point for all tasks that are stopping </p>

<p>
If this task is being stopped by a call to <a class="el" href="group__task.html#gb643e14677f59566123cdf76c5e476ee" title="Stop a task.">stop_task()</a> with the <code>wait_for_mutexes</code> parameter set, then the task will continue to run as normal until the last mutex is released. When that happens, then this task stopper will start running on the task.<p>
First, interrupts are enabled, then any mailbox being read is released<p>
If the task has a cleanup procedure defined (the <code>cleanup</code> argument to <a class="el" href="group__task.html#g9b849c9a0e0b29417cf47da99226dcc3" title="Create a task, ready to be run.">create_task()</a>), it is called<p>
Then, the task state is set to stopped, all mutexes and mailboxes are released, the (internal) task stopping semaphore is signalled, and a task switch is executed. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="f7948aead206052d6c5052462a485a97"></a><!-- doxytag: member="task.c::yavrtos_system" ref="f7948aead206052d6c5052462a485a97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structyavrtos__system__struct.html">yavrtos_system_struct</a> <a class="el" href="task_8h.html#f7948aead206052d6c5052462a485a97">yavrtos_system</a> = {0}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<p><b>For internal use only.</b></p>
<p>
The system stack, and a flag indicating whether the CPU is currently processing an interrupt </p>

<p>
<p><b>For internal use only.</b></p>
<p>
The system_struct used to hold the system stack and a flag indicating whether an ISR is currently being executed </p>

</div>
</div><p>
<hr>
<p align="center"><font size="-1">YAVRTOS and YAVRTOS documentation Copyright &copy; 2007-2009 Chris O'Byrne. Email - chris &lt;at&gt; obyrne &lt;dot&gt; com</font></p>
</body></html>
